{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\ninertial BrainInertial = inertial();\nmotor XMotor = motor(PORT3, true);\nmotor YMotor = motor(PORT6, true);\nmotor MMotor = motor(PORT2, false);\nbumper YCalSwitch = bumper(PORT4);\ncontroller Controller = controller();\ntouchled TouchLED = touchled(PORT5);\ndistance XCalDistance = distance(PORT1);\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  wait(100,msec);\n  double xAxis = BrainInertial.acceleration(xaxis) * 1000;\n  double yAxis = BrainInertial.acceleration(yaxis) * 1000;\n  double zAxis = BrainInertial.acceleration(zaxis) * 1000;\n  // Combine these values into a single integer\n  int seed = int(\n    xAxis + yAxis + zAxis\n  );\n  // Set the seed\n  srand(seed); \n}\n\n\n\nvoid vexcodeInit() {\n\n  // Initializing random seed.\n  initializeRandomSeed(); \n}\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n//----------------------------------------------------------------------------\n//                                                                            \n//    Module:       main.cpp                                                  \n//    Author:       {author}                                                  \n//    Created:      {date}                                                    \n//    Description:  IQ project                                                \n//                                                                            \n//----------------------------------------------------------------------------\n\n// Include the IQ Library\n#include \"iq_cpp.h\"\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\nconst float GEAR_RATIO_X = 5.5;\nconst float GEAR_RATIO_Y = 6;\n\nconst int MAX_DEGREES_X = 500;\nconst int MAX_DEGREES_Y = 500;\n\nvoid calibrateAllAxes();\nvoid moveTo(float x, float y);\nvoid manualControlOverride();\nvoid markerSwitch();\nvoid drawMenu(int selectedOption);\nvoid penPressure(bool applyPressure);\nvoid keepUserInformed(char C);\nint mainMenu();\n\n\n// presents a color on touch led based on a certain state of robot\nvoid KeepUserInformed(char C);\n\nclass Mover {\n  private:\n    bool XTargetSet, YTargetSet, MTargetSet;\n    float XTarget, YTarget, MTarget;\n    float DXSpeed, DYSpeed, DMSpeed,\n        UXSpeed, UYSpeed, UMSpeed;\n\n    bool paused, stopped;\n\n    // In mm/degree\n    const float X_MM_PER_DEG = 0.25;\n    const float Y_MM_PER_DEG = 0.05;\n    const float M_MM_PER_DEG = 1.8;\n\n    // In degrees/s\n    const float MAX_MOTOR_SPEED_DEG_PER_S = 90.0;\n    const float MIN_MOTOR_SPEED_PERCENT = 0.03;\n    // In mm/s\n    const float MAX_X_SPEED = X_MM_PER_DEG*MAX_MOTOR_SPEED_DEG_PER_S;\n    const float MAX_Y_SPEED = Y_MM_PER_DEG*MAX_MOTOR_SPEED_DEG_PER_S;\n    const float MAX_M_SPEED = M_MM_PER_DEG*MAX_MOTOR_SPEED_DEG_PER_S;\n    const float PERCENT = 100.0;\n\n    // In mm\n    const float MAX_TARGET_TOLERANCE = 0.8;\n    const float MAX_SPEED_AT_TARGET = 0.2;\n\n    // K-values for PID\n    const float K_P = 0.1;\n    const float K_I = 0;\n    const float K_D = 0;\n\n    const float X_MIN = 0.0;\n    const float Y_MIN = 0.0;\n    const float M_MIN = 0.0;\n\n    const float X_MAX = 11.0*25.4;\n    const float Y_MAX = 8.5*25.4;\n    const float M_MAX = 20.0;\n  \n    float getXAPos () {\n      return X_MM_PER_DEG*XMotor.position(degrees);\n    }\n    float getYAPos() {\n      return Y_MM_PER_DEG*YMotor.position(degrees);\n    }\n    int getMAPos() {\n      return M_MM_PER_DEG*MMotor.position(degrees);\n    }\n\n    void setXASpeed(float aXSpeed) {\n      if (abs(aXSpeed/MAX_X_SPEED*PERCENT) > MIN_MOTOR_SPEED_PERCENT) {\n        XMotor.setVelocity(aXSpeed/MAX_X_SPEED*PERCENT, percent);\n        XMotor.spin(forward);\n      } else {\n        XMotor.stop();\n      }\n    }\n    void setYASpeed(float aYSpeed) {\n      if (abs(aYSpeed/MAX_Y_SPEED*PERCENT) > MIN_MOTOR_SPEED_PERCENT) {\n        YMotor.setVelocity(aYSpeed/MAX_Y_SPEED*PERCENT, percent);\n        YMotor.spin(forward);\n      } else {\n        YMotor.stop();\n      }\n    }\n    void setMASpeed(float aMSpeed) {\n      if (abs(aMSpeed/MAX_M_SPEED*PERCENT) > MIN_MOTOR_SPEED_PERCENT) {\n        MMotor.setVelocity(aMSpeed/MAX_M_SPEED*PERCENT, percent);\n        MMotor.spin(forward);\n      } else {\n        MMotor.stop();\n      }\n    }\n\n    void pauseXMotor() {\n      if (UXSpeed != 0.0) {\n        setXASpeed(0.0);\n        UXSpeed = 0.0;\n      }\n    }\n    bool updateXSpeed() {\n      // Check lower bound (at origin, position = 0)\n      if (DXSpeed < 0 && getXAPos()<=X_MIN) {\n        // Below lower bound\n        pauseXMotor();\n        return false;\n      }\n      // Check upper bound\n      if (DXSpeed > 0 && getXAPos()>=X_MAX) {\n        // Above upper bound\n        pauseXMotor();\n        return false;\n      }\n      if (DXSpeed != UXSpeed) {\n        setXASpeed(DXSpeed);\n        UXSpeed = DXSpeed;\n        return true;\n      }\n      return false;\n    }\n\n    void pauseYMotor() {\n      if (UYSpeed != 0.0) {\n        setYASpeed(0.0);\n        UYSpeed = 0.0;\n      }\n    }\n    bool updateYSpeed() {\n      // Check lower bound (at origin, position = 0)\n      if (DYSpeed < 0 && getYAPos()<=Y_MIN) {\n        // Below lower bound\n        pauseYMotor();\n        return false;\n      }\n      // Check upper bound\n      if (DYSpeed > 0 && getYAPos()>=Y_MAX) {\n        // Above upper bound\n        pauseYMotor();\n        return false;\n      }\n      if (DYSpeed != UYSpeed) {\n        setYASpeed(DYSpeed);\n        UYSpeed = DYSpeed;\n        return true;\n      }\n      return false;\n    }\n\n    void pauseMMotor() {\n      if (UMSpeed != 0.0) {\n        setMASpeed(0.0);\n        UMSpeed = 0.0;\n      }\n    }\n    bool updateMSpeed() {\n      if (DMSpeed < 0 && getMAPos()<=M_MIN) {\n        // Below lower bound\n        pauseMMotor();\n      }\n      if (DMSpeed > 0 && getMAPos()>=M_MAX) {\n        // Above upper bound\n        pauseMMotor();\n      }\n      if (DMSpeed != UMSpeed) {\n        setMASpeed(DMSpeed);\n        UMSpeed = DMSpeed;\n        return true;\n      }\n      return false;\n    }\n\n    void ifXTargetSetPIDControl() {\n      if (XTargetSet) {\n        float toCover = XTarget - getXAPos();\n        if (abs(toCover) < MAX_TARGET_TOLERANCE && abs(UXSpeed) < MAX_SPEED_AT_TARGET) {\n          XTargetSet = false;\n          pauseXMotor();\n        } else {\n          DXSpeed = K_P*toCover;\n        }\n      }\n    }\n  \n  public:\n    Mover() {\n      XTargetSet = false;\n      YTargetSet = false;\n      MTargetSet = false;\n      \n      // In mm\n      XTarget = 0.0;\n      YTarget = 0.0;\n      MTarget = 0.0;\n\n      // Desired Speed In mm/s\n      DXSpeed = 0.0;\n      DYSpeed = 0.0;\n      DMSpeed = 0.0;\n\n      UXSpeed = 0.0;\n      UYSpeed = 0.0;\n      UMSpeed = 0.0;\n\n      paused = false;\n      stopped = false;\n    }\n\n    float getXSpeed() {\n      return UXSpeed;\n    }\n    float getYSpeed() {\n      return UYSpeed;\n    }\n    float getMSpeed() {\n      return UMSpeed;\n    }\n\n    bool setXSpeed(float nXSpeed) {\n      if (nXSpeed != DXSpeed) {\n        if (nXSpeed < -MAX_X_SPEED) {\n          DXSpeed = -MAX_X_SPEED;\n        } else if (nXSpeed > MAX_X_SPEED) {\n          DXSpeed = MAX_X_SPEED;\n        } else {\n          DXSpeed = nXSpeed;\n        }\n        return true;\n      }\n      return false;\n    }\n    bool setYSpeed(float nYSpeed) {\n      if (nYSpeed != DYSpeed) {\n        if (nYSpeed < -MAX_Y_SPEED) {\n          DYSpeed = -MAX_Y_SPEED;\n        } else if (nYSpeed > MAX_Y_SPEED) {\n          DYSpeed = MAX_Y_SPEED;\n        } else {\n          DYSpeed = nYSpeed;\n        }\n        return true;\n      }\n      return false;\n    }\n    bool setMSpeed(float nMSpeed) {\n      if (nMSpeed != DMSpeed) {\n        if (nMSpeed < -MAX_M_SPEED) {\n          DMSpeed = -MAX_M_SPEED;\n        } else if (nMSpeed > MAX_M_SPEED) {\n          DMSpeed = MAX_M_SPEED;\n        } else {\n        DMSpeed = nMSpeed;\n        }\n        return true;\n      }\n      return false;\n    }\n\n    bool isXTargetSet() {\n      return XTargetSet;\n    }\n    bool setXTarget(float nXTarget) {\n      if (nXTarget < X_MIN || nXTarget > X_MAX) {\n        return false;\n      }\n      XTarget = nXTarget;\n      XTargetSet = true;\n      return true;\n    }\n    bool reachedXTarget() {\n      return (abs(XTarget-getXAPos()) < MAX_TARGET_TOLERANCE);\n    }\n\n    // Return whether now paused\n    bool changePause() {\n      paused = !paused;\n      return paused;\n    }\n    // Return whether change occured\n    bool pause() {\n      if (!paused) {\n        paused = true;\n        return true;\n      }\n      return false;\n    }\n    bool unPause() {\n      if (paused) {\n        paused = false;\n        return true;\n      }\n      return false;\n    }\n\n    bool tick() {\n      if (paused) {\n        pauseXMotor();\n        pauseYMotor();\n        pauseMMotor();\n      }\n      else {\n        // Target processing\n        ifXTargetSetPIDControl();\n        \n        // Speed updating\n        if (updateXSpeed() || updateYSpeed() || updateMSpeed()) {\n          // Moved successfully\n        }\n        else {\n          // Attempting to move to unreachable location - Stuck\n          return false;\n        }\n      }\n      return true;\n    }\n};\n\nvoid calibrateAllAxes()\n{\n  const int XSAMPLES = 3;\n  const int YSAMPLES = 2;\n\n  const double APPROACH_SPEED = 10.0; //towards sensor\n  const double RETRACT_SPEED = 20; //away from sensor\n\n\n  double samplesY[YSAMPLES];\n\n  for (int i = 0; i < YSAMPLES; i++) //move away until not pressed\n  {\n    YMotor.setVelocity(RETRACT_SPEED, percent);\n    YMotor.spin(forward);\n    while (YCalSwitch.pressing()) \n    {\n    }\n    YMotor.stop(brake);\n    wait(200,msec);//pause to settle\n\n    //move slowly toards sernsor unitl pressed\n\n    YMotor.setVelocity(APPROACH_SPEED*3, percent);\n    YMotor.spin(reverse);\n    while (!YCalSwitch.pressing()) \n    {\n    }\n    YMotor.stop(brake);\n    //records position\n    samplesY[i] = YMotor.position(degrees);\n\n    //pause to settle \n    wait(2000,msec);\n    //move backwards more \n    YMotor.setVelocity(RETRACT_SPEED*2, percent);\n    YMotor.spin(forward);\n    wait(3000, msec);\n    YMotor.stop(brake);\n\n  }\n  //average contact position calculation\n  double avgDeg = (samplesY[0] + samplesY[1]) / YSAMPLES;\n  //shift encoder so the position becomes 0\n  double currentDeg = YMotor.position(degrees);\n  YMotor.setPosition(currentDeg - avgDeg, degrees);\n\n    //x axis calibration\n    double samplesX[XSAMPLES];\n\n    for (int i = 0; i < XSAMPLES; i++) //move away until not pressed\n    {\n      XMotor.setVelocity(RETRACT_SPEED, percent);\n      XMotor.spin(forward);\n      while (XCalDistance.objectDistance(mm) < 60) \n      {\n      }\n      XMotor.stop(brake);\n      wait(200, msec); //pause to settle\n\n      //mmove slowly towards sensor until \n      XMotor.setVelocity(APPROACH_SPEED*2, percent);\n      XMotor.spin(reverse);\n      while (XCalDistance.objectDistance(mm) > 40) \n      {\n      }\n      XMotor.stop(brake);\n      //records position\n      samplesX[i] = XMotor.position(degrees);\n    }\n\n    //average contact position calculation\n    double avgDegX = (samplesX[0] + samplesX[1] + samplesX[2]) / XSAMPLES;\n    double currentDegX = XMotor.position(degrees);\n    XMotor.setPosition(currentDegX - avgDegX, degrees);\n}\n\nvoid moveTo(float x, float y)\n{\n  float xLocation = -1;\n  float yLocation = -1;\n  float xDistanceOff = -1;\n  float yDistanceOff = -1;\n  bool xReached = false;\n  bool yReached = false;\n\n  XMotor.setVelocity(10, percent);\n  YMotor.setVelocity(25, percent);\n  penPressure(true);\n\n  while(xReached == false || yReached == false)\n  {\n\n    xLocation = (static_cast<float>(XMotor.position(degrees)))/GEAR_RATIO_X;\n    yLocation = (static_cast<float>(YMotor.position(degrees)))/GEAR_RATIO_Y;\n    xDistanceOff = abs(x - xLocation);\n    yDistanceOff = abs(y- yLocation);\n\n    Brain.Screen.setCursor(1,1);\n    Brain.Screen.clearLine(1);\n    Brain.Screen.print(\"X: %f\", xLocation);\n    Brain.Screen.setCursor(2,1);\n    Brain.Screen.clearLine(2);\n    Brain.Screen.print(\"Y: %f\", yLocation);\n\n    if (xLocation < x && xDistanceOff > 1)\n    {\n      XMotor.spin(forward);\n    }\n    else if (xLocation > x && xDistanceOff > 1)\n    {\n      XMotor.spin(reverse);\n    }\n    else if (xDistanceOff <= 1)\n    {\n      XMotor.stop(brake);\n      xReached = true;\n    }\n\n    if (yLocation < y && yDistanceOff > 1)\n    {\n      YMotor.spin(forward);\n    }\n    else if (yLocation > y && yDistanceOff > 1)\n    {\n      YMotor.spin(reverse);\n    }\n    else if (yDistanceOff <= 1)\n    {\n      YMotor.stop(brake);\n      yReached = true;\n    }\n  }\n}\n\nvoid manualControlOverride()\n{\n  bool markerDown = true;\n  bool markerInProgress = false;\n  bool xSpinningForward = true;\n  bool ySpinningForward = true;\n  \n  while (!Controller.ButtonFDown.pressing())\n  {\n    //moves along the x-axis\n    double xPos = XMotor.position(degrees);\n    int xAxisInput = Controller.AxisB.position();\n    \n\n    //check boundaries: stop if at limit and trying to go further\n    if ((xPos <= 0 && xAxisInput < 0) || (xPos >= MAX_DEGREES_X && xAxisInput > 0))\n    {\n      //at boundary and trying to go further will stop motor completely\n      XMotor.stop(brake);\n    }\n    else if (xAxisInput > 0)\n    {\n      //moving away from origin (forward direction)\n      if (!xSpinningForward)\n      {\n        XMotor.stop();\n        xSpinningForward = true;\n      }\n      XMotor.setVelocity(xAxisInput/3, percent);\n      XMotor.spin(forward);\n    }\n    else if (xAxisInput < 0)\n    {\n      //moving towards origin (reverse direction)\n      if (xSpinningForward)\n      {\n        XMotor.stop();\n        xSpinningForward = false;\n      }\n      XMotor.setVelocity(-xAxisInput/3, percent);\n      XMotor.spin(reverse);\n    }\n    else\n    {\n      //no input will make it stop\n      XMotor.stop(brake);\n    }\n\n    //moves along the y-axis\n    double yPos = YMotor.position(degrees);\n    int yAxisInput = Controller.AxisA.position();\n    \n    // Check boundaries: stop if at limit and trying to go further\n    if ((yPos <= 0 && yAxisInput < 0) || (yPos >= MAX_DEGREES_Y && yAxisInput > 0))\n    {\n      //at boundary and trying to go further will stop motor completely\n      YMotor.stop(brake);\n    }\n    else if (yAxisInput > 0)\n    {\n      //moving away from origin (forward direction)\n      if (!ySpinningForward)\n      {\n        YMotor.stop();\n        ySpinningForward = true;\n      }\n      YMotor.setVelocity(yAxisInput, percent);\n      YMotor.spin(forward);\n    }\n    else if (yAxisInput < 0)\n    {\n      //moving towards origin (reverse direction)\n      if (ySpinningForward)\n      {\n        YMotor.stop();\n        ySpinningForward = false;\n      }\n      YMotor.setVelocity(-yAxisInput, percent);\n      YMotor.spin(reverse);\n    }\n    else\n    {\n      //no input will make it stop\n      YMotor.stop(brake);\n    }\n    //moves marker down if pressed and marker not already down\n    if (Controller.ButtonRDown.pressing() && markerDown == false && markerInProgress == false)\n    {\n      markerInProgress = true;\n      markerDown = true;\n      // Set low torque for constant gentle pressure\n      MMotor.setMaxTorque(10, percent);\n      MMotor.setVelocity(100, percent);\n      MMotor.spin(forward);\n      markerInProgress = false;\n    }\n    //moves marker up if pressed and marker already down\n    if (Controller.ButtonRUp.pressing() && markerDown == true && markerInProgress == false)\n    {\n      markerInProgress = true;\n      markerDown = false;\n      //stop applying pressure and lift marker\n      MMotor.stop(brake);\n      //reset to full torque for lifting\n      MMotor.setMaxTorque(100, percent);\n      MMotor.setVelocity(100, percent);\n      MMotor.spin(reverse);\n      wait(200, msec);\n      MMotor.stop(brake);\n      markerInProgress = false;\n    }\n    \n    // Keep marker pressing down with low torque when in down position\n    if (markerDown && !markerInProgress)\n    {\n      MMotor.setMaxTorque(10, percent);\n      MMotor.setVelocity(100, percent);\n      MMotor.spin(forward);\n    }\n    // Display coordinates in degrees (using positions already read above)\n    Brain.Screen.setCursor(1, 1);\n    Brain.Screen.clearLine();\n    Brain.Screen.print(\"X: %.1f deg  AxisB: %d\", xPos, xAxisInput);\n    \n    Brain.Screen.setCursor(2, 1);\n    Brain.Screen.clearLine();\n    Brain.Screen.print(\"Y: %.1f deg  AxisA: %d\", yPos, yAxisInput);\n\n  }\n  XMotor.stop(brake);\n  YMotor.stop(brake);\n}\n\nvoid markerSwitch()\n{\n  //percent speed of the marker motors\n  const int MARKER_RETRACT_SPEED = 20;\n  const int MARKER_INSERTION_SPEED = 20;\n\n  //time in seconds the marker motors will spin for\n  const int MARKER_RETRACT_TIME = 2;\n  const int MARKER_INSERTION_TIME = 2; \n    \n    MMotor.setVelocity(MARKER_RETRACT_SPEED, percent);\n    MMotor.spin(reverse);\n\n    Brain.Screen.clearLine(1);\n    Brain.Screen.setCursor(1, 1);\n    Brain.Screen.print(\"Removing Marker...\");\n\n    wait(MARKER_RETRACT_TIME, seconds);\n    MMotor.stop(brake);\n\n    Brain.Screen.clearLine(1);\n    Brain.Screen.print(\"Marker ready to be inserted\");\n    Brain.Screen.setCursor(2, 1);\n    Brain.Screen.print(\"Press TouchLED when inserted\");\n\n    while(!TouchLED.pressing())\n    {\n    }\n\n    Brain.Screen.clearLine(1);\n    Brain.Screen.clearLine(2);\n\n    MMotor.setVelocity(MARKER_INSERTION_SPEED, percent);\n    MMotor.spin(forward);\n\n    Brain.Screen.setCursor(1, 1);\n    Brain.Screen.print(\"Inserting Marker...\");\n\n    wait(MARKER_INSERTION_TIME, seconds);\n    MMotor.stop(brake);\n\n    Brain.Screen.clearLine(1);\n    Brain.Screen.print(\"Marker switch complete!\");\n\n    wait(2, seconds);\n}\n\nvoid drawMenu(int selectedOption) {\n  const int NUM_OPTIONS = 5;\n  const char* menuOptions[] = {\n    \"Manual Control\",\n    \"Automator\",\n    \"Switch Marker\",\n    \"Recalibration\",\n    \"Shutdown\"\n  };\n  \n  // colors for each menu option\n  color optionColors[] = {blue, green, purple, yellow, orange};\n  \n  // Clear screen with the selected option's color\n  Brain.Screen.clearScreen(optionColors[selectedOption]);\n  \n  Brain.Screen.setPenColor(white);\n  Brain.Screen.setFont(mono15);\n  \n  // Draw menu options\n  for (int i = 0; i < NUM_OPTIONS; i++) {\n    Brain.Screen.setCursor(i + 1, 1);\n    \n    // Highlight selected option with arrow and bright color\n    if (i == selectedOption) {\n      Brain.Screen.setPenColor(yellow);\n      Brain.Screen.print(\"> %s <\", menuOptions[i]);\n    } else {\n      Brain.Screen.setPenColor(white);\n      Brain.Screen.print(\"  %s\", menuOptions[i]);\n    }\n  }\n  \n  Brain.Screen.setPenColor(white);\n  \n  // Navigation instructions\n  Brain.Screen.setPenColor(white);\n  Brain.Screen.setCursor(7, 1);\n  Brain.Screen.setFont(mono12);\n  Brain.Screen.print(\"Left/Right: Navigate\");\n  Brain.Screen.setCursor(8, 1);\n  Brain.Screen.print(\"Check: Select\");\n}\n\nint mainMenu ()\n{\n  int selectedOption = 0;\n  const int NUM_OPTIONS = 5;\n  \n  bool buttonPressed = false;\n  bool needsRedraw = true;\n  \n  while (true) {\n    // Only redraw when selection changes\n    if (needsRedraw) {\n      drawMenu(selectedOption);\n      needsRedraw = false;\n    }\n    \n    // Check for buttonLeft (navigate up)\n    if (Brain.buttonLeft.pressing()) {\n      if (!buttonPressed) {\n        buttonPressed = true;\n        selectedOption--;\n        if (selectedOption < 0) {\n          selectedOption = NUM_OPTIONS - 1; // Wrap to bottom\n        }\n        needsRedraw = true;\n        wait(200, msec); // Debounce\n      }\n    }\n    // Check for buttonRight (navigate down)\n    else if (Brain.buttonRight.pressing()) {\n      if (!buttonPressed) {\n        buttonPressed = true;\n        selectedOption++;\n        if (selectedOption >= NUM_OPTIONS) {\n          selectedOption = 0; // Wrap to top\n        }\n        needsRedraw = true;\n        wait(200, msec); // Debounce\n      }\n    }\n    // Check for buttonCheck (select option)\n    else if (Brain.buttonCheck.pressing()) {\n      if (!buttonPressed) {\n        buttonPressed = true;\n        wait(200, msec); // Show selection briefly\n        return selectedOption;\n      }\n    }\n    else {\n      buttonPressed = false;\n    }\n    \n    wait(50, msec);\n  }\n  \n  return selectedOption;\n}\n\nvoid penPressure(bool applyPressure)\n{\n  if (applyPressure == true) {\n      MMotor.setMaxTorque(5, percent);\n      MMotor.setVelocity(20, percent);\n      MMotor.spin(forward);\n  }\n  else {\n    MMotor.stop(brake);\n    MMotor.setMaxTorque(100, percent);\n    MMotor.setVelocity(50, percent);\n  }\n}\n\n// presents a color on touch led based on a certain state of robot\nvoid keepUserInformed(char C)\n{\n  // while homing all axies\n  if (C == 'H')\n  {\n    TouchLED.setColor(yellow);\n  }\n\n  // startup done and completed\n  else if (C == 'S')\n  {\n    TouchLED.setColor(green);\n  }\n\n  // autodraw\n  else if (C == 'A')\n  {\n    TouchLED.setColor(orange);\n  }\n\n  // controller\n  else if (C == 'C')\n  {\n    TouchLED.setColor(blue);\n  }\n\n  // marker switcher\n  else if (C == 'M')\n  {\n    TouchLED.setColor(purple);\n  }\n\n  // limit triggered unexpectedly \n  else if (C == 'T')\n  {\n    // use return to main menu function\n  }\n\n  // paper is removed\n  else if (C == 'R')\n  {\n    TouchLED.setColor(red);\n    while (!TouchLED.pressing())\n    {\n      wait(0.5, seconds);\n      TouchLED.setFade(fast);\n      wait(0.5, seconds);\n      TouchLED.setBrightness(100);\n    }\n    TouchLED.off(); \n  }\n\n  // shutdown procedure\n  else if (C == 'P')\n  {\n    TouchLED.setColor(red);\n  }\n\n} \n\nint main() {\n  // Initializing Robot Configuration. DO NOT REMOVE!\n  vexcodeInit();\n  XMotor.setPosition(0, degrees);\n  YMotor.setPosition(0, degrees);\n  MMotor.setPosition(0, degrees);\n\n  // Begin project code\n  \n  // Initial calibration\n  calibrateAllAxes();\n  // Main menu loop\n  while (true) {\n    int selection = mainMenu();\n\n    switch (selection) {\n      case 0: // Manual Control\n        //Brain.Screen.clearScreen();\n        Brain.Screen.setCursor(1, 1);\n        Brain.Screen.print(\"Starting Manual Mode\");\n        wait(500, msec);\n        manualControlOverride();\n        break;\n        \n      case 1: // Automator\n        //Brain.Screen.clearScreen();\n        moveTo(0, 400);\n        moveTo(400, 400);\n        moveTo(400, 0);\n        moveTo(0,0);\n        Brain.Screen.setCursor(1, 1);\n        Brain.Screen.print(\"Automator Mode\");\n        keepUserInformed('A');\n        Brain.Screen.setCursor(2, 1);\n        Brain.Screen.print(\"Not implemented yet\");\n        wait(2, seconds);\n        break;\n        \n      case 2: // Switch Marker\n        //Brain.Screen.clearScreen();\n        Brain.Screen.setCursor(1, 1);\n        Brain.Screen.print(\"Starting Marker Switch\");\n        keepUserInformed('M');\n        wait(500, msec);\n        markerSwitch();\n        break;\n        \n      case 3: // Recalibration\n        //Brain.Screen.clearScreen();\n        Brain.Screen.setCursor(1, 1);\n        Brain.Screen.print(\"Recalibrating...\");\n        calibrateAllAxes();\n        Brain.Screen.setCursor(2, 1);\n        Brain.Screen.print(\"Done!\");\n        wait(1, seconds);\n        break;\n        \n      case 4: // Shutdown\n        //Brain.Screen.clearScreen();\n        Brain.Screen.setCursor(1, 1);\n        Brain.Screen.print(\"Shutting down...\");\n        keepUserInformed('P');\n        wait(1, seconds);\n        Brain.programStop();\n        return 0;\n    }\n  }\n\n  Brain.programStop();\n}\n","textLanguage":"cpp","robotConfig":[{"port":[3],"name":"XMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[6],"name":"YMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[2],"name":"MMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[4],"name":"YCalSwitch","customName":true,"deviceType":"Bumper","deviceClass":"bumper","setting":{},"triportSourcePort":22},{"port":[],"name":"Controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22},{"port":[5],"name":"TouchLED","customName":true,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[1],"name":"XCalDistance","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.62.0","fileFormat":"2.0.0","targetBrainGen":"Second","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null}}