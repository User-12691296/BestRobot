{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\ninertial BrainInertial = inertial();\nmotor XMotor = motor(PORT3, true);\nmotor YMotor = motor(PORT6, false);\nmotor MMotor = motor(PORT2, false);\nbumper YCalSwitch = bumper(PORT4);\ncontroller Controller = controller();\noptical XCalOptical = optical(PORT1);\ntouchled TouchLED = touchled(PORT5);\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  wait(100,msec);\n  double xAxis = BrainInertial.acceleration(xaxis) * 1000;\n  double yAxis = BrainInertial.acceleration(yaxis) * 1000;\n  double zAxis = BrainInertial.acceleration(zaxis) * 1000;\n  // Combine these values into a single integer\n  int seed = int(\n    xAxis + yAxis + zAxis\n  );\n  // Set the seed\n  srand(seed); \n}\n\n// Converts a color to a string\nconst char* convertColorToString(color col) {\n  if (col == colorType::red) return \"red\";\n  else if (col == colorType::green) return \"green\";\n  else if (col == colorType::blue) return \"blue\";\n  else if (col == colorType::white) return \"white\";\n  else if (col == colorType::yellow) return \"yellow\";\n  else if (col == colorType::orange) return \"orange\";\n  else if (col == colorType::purple) return \"purple\";\n  else if (col == colorType::cyan) return \"cyan\";\n  else if (col == colorType::black) return \"black\";\n  else if (col == colorType::transparent) return \"transparent\";\n  else if (col == colorType::red_violet) return \"red_violet\";\n  else if (col == colorType::violet) return \"violet\";\n  else if (col == colorType::blue_violet) return \"blue_violet\";\n  else if (col == colorType::blue_green) return \"blue_green\";\n  else if (col == colorType::yellow_green) return \"yellow_green\";\n  else if (col == colorType::yellow_orange) return \"yellow_orange\";\n  else if (col == colorType::red_orange) return \"red_orange\";\n  else if (col == colorType::none) return \"none\";\n  else return \"unknown\";\n}\n\n\n// Convert colorType to string\nconst char* convertColorToString(colorType col) {\n  if (col == colorType::red) return \"red\";\n  else if (col == colorType::green) return \"green\";\n  else if (col == colorType::blue) return \"blue\";\n  else if (col == colorType::white) return \"white\";\n  else if (col == colorType::yellow) return \"yellow\";\n  else if (col == colorType::orange) return \"orange\";\n  else if (col == colorType::purple) return \"purple\";\n  else if (col == colorType::cyan) return \"cyan\";\n  else if (col == colorType::black) return \"black\";\n  else if (col == colorType::transparent) return \"transparent\";\n  else if (col == colorType::red_violet) return \"red_violet\";\n  else if (col == colorType::violet) return \"violet\";\n  else if (col == colorType::blue_violet) return \"blue_violet\";\n  else if (col == colorType::blue_green) return \"blue_green\";\n  else if (col == colorType::yellow_green) return \"yellow_green\";\n  else if (col == colorType::yellow_orange) return \"yellow_orange\";\n  else if (col == colorType::red_orange) return \"red_orange\";\n  else if (col == colorType::none) return \"none\";\n  else return \"unknown\";\n}\n\n\nvoid vexcodeInit() {\n\n  // Initializing random seed.\n  initializeRandomSeed(); \n}\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n//----------------------------------------------------------------------------\n//                                                                            \n//    Module:       main.cpp                                                  \n//    Author:       {author}                                                  \n//    Created:      {date}                                                    \n//    Description:  IQ project                                                \n//                                                                            \n//----------------------------------------------------------------------------\n\n// Include the IQ Library\n#include \"iq_cpp.h\"\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\nclass Mover {\n  private:\n    bool XTargetSet, YTargetSet, MTargetSet;\n    float XTarget, YTarget, MTarget;\n    float DXSpeed, DYSpeed, DMSpeed,\n        UXSpeed, UYSpeed, UMSpeed;\n\n    bool paused, stopped;\n\n    // In mm/degree\n    const float X_MM_PER_DEG = 0.25;\n    const float Y_MM_PER_DEG = 0.05;\n    const float M_MM_PER_DEG = 1.8;\n\n    // In degrees/s\n    const float MAX_MOTOR_SPEED_DEG_PER_S = 90.0;\n    const float MIN_MOTOR_SPEED_PERCENT = 0.03;\n    // In mm/s\n    const float MAX_X_SPEED = X_MM_PER_DEG*MAX_MOTOR_SPEED_DEG_PER_S;\n    const float MAX_Y_SPEED = Y_MM_PER_DEG*MAX_MOTOR_SPEED_DEG_PER_S;\n    const float MAX_M_SPEED = M_MM_PER_DEG*MAX_MOTOR_SPEED_DEG_PER_S;\n    const float PERCENT = 100.0;\n\n    // In mm\n    const float MAX_TARGET_TOLERANCE = 0.8;\n    const float MAX_SPEED_AT_TARGET = 0.2;\n\n    // K-values for PID\n    const float K_P = 0.1;\n    const float K_I = 0;\n    const float K_D = 0;\n\n    const float X_MIN = 0.0;\n    const float Y_MIN = 0.0;\n    const float M_MIN = 0.0;\n\n    const float X_MAX = 11.0*25.4;\n    const float Y_MAX = 8.5*25.4;\n    const float M_MAX = 20.0;\n  \n    int getXAPos () {\n      return X_MM_PER_DEG*XMotor.position(degrees);\n    }\n    int getYAPos() {\n      return Y_MM_PER_DEG*YMotor.position(degrees);\n    }\n    int getMAPos() {\n      return M_MM_PER_DEG*MMotor.position(degrees);\n    }\n\n    void setXASpeed(float aXSpeed) {\n      if (abs(aXSpeed/MAX_X_SPEED*PERCENT) > MIN_MOTOR_SPEED_PERCENT) {\n        XMotor.setVelocity(aXSpeed/MAX_X_SPEED*PERCENT, percent);\n        XMotor.spin(forward);\n      } else {\n        XMotor.stop();\n      }\n    }\n    void setYASpeed(float aYSpeed) {\n      if (abs(aYSpeed/MAX_Y_SPEED*PERCENT) > MIN_MOTOR_SPEED_PERCENT) {\n        YMotor.setVelocity(aYSpeed/MAX_Y_SPEED*PERCENT, percent);\n        YMotor.spin(forward);\n      } else {\n        YMotor.stop();\n      }\n    }\n    void setMASpeed(float aMSpeed) {\n      if (abs(aMSpeed/MAX_M_SPEED*PERCENT) > MIN_MOTOR_SPEED_PERCENT) {\n        MMotor.setVelocity(aMSpeed/MAX_M_SPEED*PERCENT, percent);\n        MMotor.spin(forward);\n      } else {\n        MMotor.stop();\n      }\n    }\n\n    void pauseXMotor() {\n      if (UXSpeed != 0.0) {\n        setXASpeed(0.0);\n        UXSpeed = 0.0;\n      }\n    }\n    bool updateXSpeed() {\n      if (DXSpeed < 0 && getXAPos()<=X_MIN) {\n        // Below lower bound\n        pauseXMotor();\n      }\n      if (DXSpeed > 0 && getXAPos()>=X_MAX) {\n        // Above upper bound\n        pauseXMotor();\n      }\n      if (DXSpeed != UXSpeed) {\n        setXASpeed(DXSpeed);\n        UXSpeed = DXSpeed;\n        return true;\n      }\n      return false;\n    }\n\n    void pauseYMotor() {\n      if (UYSpeed != 0.0) {\n        setYASpeed(0.0);\n        UYSpeed = 0.0;\n      }\n    }\n    bool updateYSpeed() {\n      if (DYSpeed < 0 && getYAPos()<=Y_MIN) {\n        // Below lower bound\n        pauseYMotor();\n      }\n      if (DYSpeed > 0 && getYAPos()>=Y_MAX) {\n        // Above upper bound\n        pauseYMotor();\n      }\n      if (DYSpeed != UYSpeed) {\n        setYASpeed(DYSpeed);\n        UYSpeed = DYSpeed;\n        return true;\n      }\n      return false;\n    }\n\n    void pauseMMotor() {\n      if (UMSpeed != 0.0) {\n        setMASpeed(0.0);\n        UMSpeed = 0.0;\n      }\n    }\n    bool updateMSpeed() {\n      if (DMSpeed < 0 && getMAPos()<=M_MIN) {\n        // Below lower bound\n        pauseMMotor();\n      }\n      if (DMSpeed > 0 && getMAPos()>=M_MAX) {\n        // Above upper bound\n        pauseMMotor();\n      }\n      if (DMSpeed != UMSpeed) {\n        setMASpeed(DMSpeed);\n        UMSpeed = DMSpeed;\n        return true;\n      }\n      return false;\n    }\n\n    void ifXTargetSetPIDControl() {\n      if (XTargetSet) {\n        float toCover = XTarget - getXAPos();\n        if (abs(toCover) < MAX_TARGET_TOLERANCE && abs(UXSpeed) < MAX_SPEED_AT_TARGET) {\n          XTargetSet = false;\n          pauseXMotor();\n        } else {\n          DXSpeed = K_P*toCover;\n        }\n      }\n    }\n  \n  public:\n    Mover() {\n      XTargetSet = false;\n      YTargetSet = false;\n      MTargetSet = false;\n      \n      // In mm\n      XTarget = 0.0;\n      YTarget = 0.0;\n      MTarget = 0.0;\n\n      // Desired Speed In mm/s\n      DXSpeed = 0.0;\n      DYSpeed = 0.0;\n      DMSpeed = 0.0;\n\n      UXSpeed = 0.0;\n      UYSpeed = 0.0;\n      UMSpeed = 0.0;\n\n      paused = false;\n      stopped = false;\n    }\n\n    float getXSpeed() {\n      return UXSpeed;\n    }\n    float getYSpeed() {\n      return UYSpeed;\n    }\n    float getMSpeed() {\n      return UMSpeed;\n    }\n\n    bool setXSpeed(float nXSpeed) {\n      if (nXSpeed != DXSpeed) {\n        if (nXSpeed < -MAX_X_SPEED) {\n          DXSpeed = -MAX_X_SPEED;\n        } else if (nXSpeed > MAX_X_SPEED) {\n          DXSpeed = MAX_X_SPEED;\n        } else {\n          DXSpeed = nXSpeed;\n        }\n        return true;\n      }\n      return false;\n    }\n    bool setYSpeed(float nYSpeed) {\n      if (nYSpeed != DYSpeed) {\n        if (nYSpeed < -MAX_Y_SPEED) {\n          DYSpeed = -MAX_Y_SPEED;\n        } else if (nYSpeed > MAX_Y_SPEED) {\n          DYSpeed = MAX_Y_SPEED;\n        } else {\n          DYSpeed = nYSpeed;\n        }\n        return true;\n      }\n      return false;\n    }\n    bool setMSpeed(float nMSpeed) {\n      if (nMSpeed != DMSpeed) {\n        if (nMSpeed < -MAX_M_SPEED) {\n          DMSpeed = -MAX_M_SPEED;\n        } else if (nMSpeed > MAX_M_SPEED) {\n          DMSpeed = MAX_M_SPEED;\n        } else {\n        DMSpeed = nMSpeed;\n        }\n        return true;\n      }\n      return false;\n    }\n\n    bool isXTargetSet() {\n      return XTargetSet;\n    }\n    bool setXTarget(float nXTarget) {\n      if (nXTarget < X_MIN || nXTarget > X_MAX) {\n        return false;\n      }\n      XTarget = nXTarget;\n      XTargetSet = true;\n      return true;\n    }\n    bool reachedXTarget() {\n      return (abs(XTarget-getXAPos()) < MAX_TARGET_TOLERANCE);\n    }\n\n    // Return whether now paused\n    bool changePause() {\n      paused = !paused;\n      return paused;\n    }\n    // Return whether change occured\n    bool pause() {\n      if (!paused) {\n        paused = true;\n        return true;\n      }\n      return false;\n    }\n    bool unPause() {\n      if (paused) {\n        paused = false;\n        return true;\n      }\n      return false;\n    }\n\n    bool tick() {\n      if (paused) {\n        pauseXMotor();\n        pauseYMotor();\n        pauseMMotor();\n      }\n      else {\n        // Target processing\n        ifXTargetSetPIDControl();\n        \n        // Speed updating\n        if (updateXSpeed() || updateYSpeed() || updateMSpeed()) {\n          // Moved successfully\n        }\n        else {\n          // Attempting to move to unreachable location - Stuck\n          return false;\n        }\n      }\n      return true;\n    }\n};\n\nvoid calibrateYaxis()\n{\n  const int SAMPLES = 3;\n  Const double APPROCH_SPEED = 10.0; //towards sensor\n  const double RETRACT_SPEED = 20; //away from sensor\n\n  double samples[samples];\n\n  for (int i = 0; i < samples; i++) //move away until not pressed\n  {\n    YMotor.setVelocity(RETRACT_SPEED, percent);\n    YMotor.spin(forward);\n    while (!YCalSwitch.pressing())\n    {}\n    while (YCalSwitch.pressing()) \n    {\n    wait(10,msec)  \n    }\n    YMotor.stop(brake)\n\n\n  }\n\n\n}\n\nvoid manualControlOverride(float maxX, float maxY)\n{\n  XMotor.spin(forward);\n  YMotor.spin(forward);\n  while (!Controller.ButtonFDown.pressing())\n  {\n    if (XCalOptical.color() != black)\n    {\n      XMotor.setVelocity(Controller.AxisB.position(), percent);\n    }\n    else\n    {\n      XMotor.setVelocity(0, percent);\n    }\n    YMotor.setVelocity(Controller.AxisA.position(), percent);\n  }\n  XMotor.stop(brake);\n  YMotor.stop(brake);\n}\n\nint main() {\n  // Initializing Robot Configuration. DO NOT REMOVE!\n  vexcodeInit();\n  XMotor.setPosition(0, degrees);\n  YMotor.setPosition(0, degrees);\n  MMotor.setPosition(0, degrees);\n\n  // Begin project code\n\n  Mover m;\n\n  m.setXSpeed(3);\n\n  for (int i=0; i<500000; i++) {\n    m.tick();\n    if (i==250000) {\n      m.setXSpeed(-3);\n    }\n  }\n\n  Brain.programStop();\n}\n","textLanguage":"cpp","robotConfig":[{"port":[3],"name":"XMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[6],"name":"YMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[2],"name":"MMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[4],"name":"YCalSwitch","customName":true,"deviceType":"Bumper","deviceClass":"bumper","setting":{},"triportSourcePort":22},{"port":[],"name":"Controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"}},{"port":[1],"name":"XCalOptical","customName":true,"deviceType":"Optical","deviceClass":"optical","setting":{}},{"port":[5],"name":"TouchLED","customName":true,"deviceType":"TouchLED","deviceClass":"touchled","setting":{}}],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.62.0","fileFormat":"2.0.0","targetBrainGen":"Second","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null}}