{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\ninertial BrainInertial = inertial();\nmotor XMotor = motor(PORT3, true);\nmotor YMotor = motor(PORT6, true);\nmotor MMotor = motor(PORT2, false);\nbumper YCalSwitch = bumper(PORT4);\ncontroller Controller = controller();\ntouchled TouchLED = touchled(PORT5);\ndistance XCalDistance = distance(PORT1);\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  wait(100,msec);\n  double xAxis = BrainInertial.acceleration(xaxis) * 1000;\n  double yAxis = BrainInertial.acceleration(yaxis) * 1000;\n  double zAxis = BrainInertial.acceleration(zaxis) * 1000;\n  // Combine these values into a single integer\n  int seed = int(\n    xAxis + yAxis + zAxis\n  );\n  // Set the seed\n  srand(seed);\n}\n\n\n\nvoid vexcodeInit() {\n\n  // Initializing random seed.\n  initializeRandomSeed();\n}\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n//----------------------------------------------------------------------------\n//\n//    Module:       main.cpp\n//    Author:       {author}\n//    Created:      {date}\n//    Description:  IQ project\n//\n//----------------------------------------------------------------------------\n\n// Include the IQ Library\n#include \"iq_cpp.h\"\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\nconst float GEAR_RATIO_X = 137.84;\nconst float GEAR_RATIO_Y = 480;\n\nconst int MAX_DEGREES_X = 1000;\nconst int MAX_DEGREES_Y = 500;\n\nvoid calibrateAllAxes();\nvoid moveTo(float x, float y);\nvoid markerDown();\nvoid markerUp();\nvoid manualControlOverride();\nvoid markerSwitch();\nvoid drawMenu(int selectedOption);\nvoid penPressure(bool applyPressure);\nvoid keepUserInformed(char C);\nint mainMenu();\n\n\n// presents a color on touch led based on a certain state of robot\nvoid KeepUserInformed(char C);\n\nclass Mover {\n  private:\n    bool XTargetSet, YTargetSet, MTargetSet;\n    float XTarget, YTarget, MTarget;\n    float DXSpeed, DYSpeed, DMSpeed,\n        UXSpeed, UYSpeed, UMSpeed;\n\n    bool paused, stopped;\n\n    // In mm/degree\n    const float X_MM_PER_DEG = 0.25;\n    const float Y_MM_PER_DEG = 0.05;\n    const float M_MM_PER_DEG = 1.8;\n\n    // In degrees/s\n    const float MAX_MOTOR_SPEED_DEG_PER_S = 90.0;\n    const float MIN_MOTOR_SPEED_PERCENT = 0.03;\n    // In mm/s\n    const float MAX_X_SPEED = X_MM_PER_DEG*MAX_MOTOR_SPEED_DEG_PER_S;\n    const float MAX_Y_SPEED = Y_MM_PER_DEG*MAX_MOTOR_SPEED_DEG_PER_S;\n    const float MAX_M_SPEED = M_MM_PER_DEG*MAX_MOTOR_SPEED_DEG_PER_S;\n    const float PERCENT = 100.0;\n\n    // In mm\n    const float MAX_TARGET_TOLERANCE = 0.8;\n    const float MAX_SPEED_AT_TARGET = 0.2;\n\n    // K-values for PID\n    const float K_P = 0.1;\n    const float K_I = 0;\n    const float K_D = 0;\n\n    const float X_MIN = 0.0;\n    const float Y_MIN = 0.0;\n    const float M_MIN = 0.0;\n\n    const float X_MAX = 11.0*25.4;\n    const float Y_MAX = 8.5*25.4;\n    const float M_MAX = 20.0;\n\n    float getXAPos () {\n      return X_MM_PER_DEG*XMotor.position(degrees);\n    }\n    float getYAPos() {\n      return Y_MM_PER_DEG*YMotor.position(degrees);\n    }\n    int getMAPos() {\n      return M_MM_PER_DEG*MMotor.position(degrees);\n    }\n\n    void setXASpeed(float aXSpeed) {\n      if (abs(aXSpeed/MAX_X_SPEED*PERCENT) > MIN_MOTOR_SPEED_PERCENT) {\n        XMotor.setVelocity(aXSpeed/MAX_X_SPEED*PERCENT, percent);\n        XMotor.spin(forward);\n      } else {\n        XMotor.stop();\n      }\n    }\n    void setYASpeed(float aYSpeed) {\n      if (abs(aYSpeed/MAX_Y_SPEED*PERCENT) > MIN_MOTOR_SPEED_PERCENT) {\n        YMotor.setVelocity(aYSpeed/MAX_Y_SPEED*PERCENT, percent);\n        YMotor.spin(forward);\n      } else {\n        YMotor.stop();\n      }\n    }\n    void setMASpeed(float aMSpeed) {\n      if (abs(aMSpeed/MAX_M_SPEED*PERCENT) > MIN_MOTOR_SPEED_PERCENT) {\n        MMotor.setVelocity(aMSpeed/MAX_M_SPEED*PERCENT, percent);\n        MMotor.spin(forward);\n      } else {\n        MMotor.stop();\n      }\n    }\n\n    void pauseXMotor() {\n      if (UXSpeed != 0.0) {\n        setXASpeed(0.0);\n        UXSpeed = 0.0;\n      }\n    }\n    bool updateXSpeed() {\n      // Check lower bound (at origin, position = 0)\n      if (DXSpeed < 0 && getXAPos()<=X_MIN) {\n        // Below lower bound\n        pauseXMotor();\n        return false;\n      }\n      // Check upper bound\n      if (DXSpeed > 0 && getXAPos()>=X_MAX) {\n        // Above upper bound\n        pauseXMotor();\n        return false;\n      }\n      if (DXSpeed != UXSpeed) {\n        setXASpeed(DXSpeed);\n        UXSpeed = DXSpeed;\n        return true;\n      }\n      return false;\n    }\n\n    void pauseYMotor() {\n      if (UYSpeed != 0.0) {\n        setYASpeed(0.0);\n        UYSpeed = 0.0;\n      }\n    }\n    bool updateYSpeed() {\n      // Check lower bound (at origin, position = 0)\n      if (DYSpeed < 0 && getYAPos()<=Y_MIN) {\n        // Below lower bound\n        pauseYMotor();\n        return false;\n      }\n      // Check upper bound\n      if (DYSpeed > 0 && getYAPos()>=Y_MAX) {\n        // Above upper bound\n        pauseYMotor();\n        return false;\n      }\n      if (DYSpeed != UYSpeed) {\n        setYASpeed(DYSpeed);\n        UYSpeed = DYSpeed;\n        return true;\n      }\n      return false;\n    }\n\n    void pauseMMotor() {\n      if (UMSpeed != 0.0) {\n        setMASpeed(0.0);\n        UMSpeed = 0.0;\n      }\n    }\n    bool updateMSpeed() {\n      if (DMSpeed < 0 && getMAPos()<=M_MIN) {\n        // Below lower bound\n        pauseMMotor();\n      }\n      if (DMSpeed > 0 && getMAPos()>=M_MAX) {\n        // Above upper bound\n        pauseMMotor();\n      }\n      if (DMSpeed != UMSpeed) {\n        setMASpeed(DMSpeed);\n        UMSpeed = DMSpeed;\n        return true;\n      }\n      return false;\n    }\n\n    void ifXTargetSetPIDControl() {\n      if (XTargetSet) {\n        float toCover = XTarget - getXAPos();\n        if (abs(toCover) < MAX_TARGET_TOLERANCE && abs(UXSpeed) < MAX_SPEED_AT_TARGET) {\n          XTargetSet = false;\n          pauseXMotor();\n        } else {\n          DXSpeed = K_P*toCover;\n        }\n      }\n    }\n\n  public:\n    Mover() {\n      XTargetSet = false;\n      YTargetSet = false;\n      MTargetSet = false;\n\n      // In mm\n      XTarget = 0.0;\n      YTarget = 0.0;\n      MTarget = 0.0;\n\n      // Desired Speed In mm/s\n      DXSpeed = 0.0;\n      DYSpeed = 0.0;\n      DMSpeed = 0.0;\n\n      UXSpeed = 0.0;\n      UYSpeed = 0.0;\n      UMSpeed = 0.0;\n\n      paused = false;\n      stopped = false;\n    }\n\n    float getXSpeed() {\n      return UXSpeed;\n    }\n    float getYSpeed() {\n      return UYSpeed;\n    }\n    float getMSpeed() {\n      return UMSpeed;\n    }\n\n    bool setXSpeed(float nXSpeed) {\n      if (nXSpeed != DXSpeed) {\n        if (nXSpeed < -MAX_X_SPEED) {\n          DXSpeed = -MAX_X_SPEED;\n        } else if (nXSpeed > MAX_X_SPEED) {\n          DXSpeed = MAX_X_SPEED;\n        } else {\n          DXSpeed = nXSpeed;\n        }\n        return true;\n      }\n      return false;\n    }\n    bool setYSpeed(float nYSpeed) {\n      if (nYSpeed != DYSpeed) {\n        if (nYSpeed < -MAX_Y_SPEED) {\n          DYSpeed = -MAX_Y_SPEED;\n        } else if (nYSpeed > MAX_Y_SPEED) {\n          DYSpeed = MAX_Y_SPEED;\n        } else {\n          DYSpeed = nYSpeed;\n        }\n        return true;\n      }\n      return false;\n    }\n    bool setMSpeed(float nMSpeed) {\n      if (nMSpeed != DMSpeed) {\n        if (nMSpeed < -MAX_M_SPEED) {\n          DMSpeed = -MAX_M_SPEED;\n        } else if (nMSpeed > MAX_M_SPEED) {\n          DMSpeed = MAX_M_SPEED;\n        } else {\n        DMSpeed = nMSpeed;\n        }\n        return true;\n      }\n      return false;\n    }\n\n    bool isXTargetSet() {\n      return XTargetSet;\n    }\n    bool setXTarget(float nXTarget) {\n      if (nXTarget < X_MIN || nXTarget > X_MAX) {\n        return false;\n      }\n      XTarget = nXTarget;\n      XTargetSet = true;\n      return true;\n    }\n    bool reachedXTarget() {\n      return (abs(XTarget-getXAPos()) < MAX_TARGET_TOLERANCE);\n    }\n\n    // Return whether now paused\n    bool changePause() {\n      paused = !paused;\n      return paused;\n    }\n    // Return whether change occured\n    bool pause() {\n      if (!paused) {\n        paused = true;\n        return true;\n      }\n      return false;\n    }\n    bool unPause() {\n      if (paused) {\n        paused = false;\n        return true;\n      }\n      return false;\n    }\n\n    bool tick() {\n      if (paused) {\n        pauseXMotor();\n        pauseYMotor();\n        pauseMMotor();\n      }\n      else {\n        // Target processing\n        ifXTargetSetPIDControl();\n\n        // Speed updating\n        if (updateXSpeed() || updateYSpeed() || updateMSpeed()) {\n          // Moved successfully\n        }\n        else {\n          // Attempting to move to unreachable location - Stuck\n          return false;\n        }\n      }\n      return true;\n    }\n};\n\nvoid calibrateAllAxes()\n{\n  const int XSAMPLES = 3;\n  const int YSAMPLES = 2;\n\n  const double APPROACH_SPEED = 10.0; //towards sensor\n  const double RETRACT_SPEED = 20; //away from sensor\n\n\n  double samplesY[YSAMPLES];\n\n  for (int i = 0; i < YSAMPLES; i++) //move away until not pressed\n  {\n    YMotor.setVelocity(RETRACT_SPEED, percent);\n    YMotor.spin(forward);\n    while (YCalSwitch.pressing())\n    {\n    }\n    YMotor.stop(brake);\n    wait(200,msec);//pause to settle\n\n    //move slowly toards sernsor unitl pressed\n\n    YMotor.setVelocity(APPROACH_SPEED*3, percent);\n    YMotor.spin(reverse);\n    while (!YCalSwitch.pressing())\n    {\n    }\n    YMotor.stop(brake);\n    //records position\n    samplesY[i] = YMotor.position(degrees);\n\n    //pause to settle\n    wait(2000,msec);\n    //move backwards more\n    YMotor.setVelocity(RETRACT_SPEED*2, percent);\n    YMotor.spin(forward);\n    wait(3000, msec);\n    YMotor.stop(brake);\n\n  }\n  //average contact position calculation\n  double avgDeg = (samplesY[0] + samplesY[1]) / YSAMPLES;\n  //shift encoder so the position becomes 0\n  double currentDeg = YMotor.position(degrees);\n  YMotor.setPosition(currentDeg - avgDeg, degrees);\n\n    //x axis calibration\n    double samplesX[XSAMPLES];\n\n    for (int i = 0; i < XSAMPLES; i++) //move away until not pressed\n    {\n      XMotor.setVelocity(RETRACT_SPEED, percent);\n      XMotor.spin(forward);\n      while (XCalDistance.objectDistance(mm) < 60)\n      {\n      }\n      XMotor.stop(brake);\n      wait(200, msec); //pause to settle\n\n      //mmove slowly towards sensor until\n      XMotor.setVelocity(APPROACH_SPEED*2, percent);\n      XMotor.spin(reverse);\n      while (XCalDistance.objectDistance(mm) > 40)\n      {\n      }\n      XMotor.stop(brake);\n      //records position\n      samplesX[i] = XMotor.position(degrees);\n    }\n\n    //average contact position calculation\n    double avgDegX = (samplesX[0] + samplesX[1] + samplesX[2]) / XSAMPLES;\n    double currentDegX = XMotor.position(degrees);\n    XMotor.setPosition(currentDegX - avgDegX, degrees);\n\n    wait(2000, msec);\n\n    moveTo(0,0);\n}\n\nvoid moveTo(float x, float y)\n{\n  float xLocation = -1;\n  float yLocation = -1;\n\n  float xDistanceOff = -1;\n  float yDistanceOff = -1;\n  const float ERROR_MARGIN = 0.1;\n\n  bool xReached = false;\n  bool yReached = false;\n\n  const int X_VELOCITY = 10;\n  const int Y_VELOCITY = 20;\n\n  XMotor.setVelocity(X_VELOCITY, percent);\n  YMotor.setVelocity(Y_VELOCITY, percent);\n\n  XMotor.spin(forward);\n  YMotor.spin(forward);\n\n  while(xReached == false || yReached == false)\n  {\n\n    xLocation = (static_cast<float>(XMotor.position(degrees)))/GEAR_RATIO_X;\n    yLocation = (static_cast<float>(YMotor.position(degrees)))/GEAR_RATIO_Y;\n    xDistanceOff = abs(x - xLocation);\n    yDistanceOff = abs(y - yLocation);\n\n    Brain.Screen.setCursor(1,1);\n    Brain.Screen.clearLine(1);\n    Brain.Screen.print(\"X: %f\", xLocation);\n    Brain.Screen.setCursor(2,1);\n    Brain.Screen.clearLine(2);\n    Brain.Screen.print(\"Y: %f\", yLocation);\n\n    if (xLocation < x && xDistanceOff > ERROR_MARGIN)\n    {\n      XMotor.setVelocity(X_VELOCITY, percent);\n    }\n    else if (xLocation > x && xDistanceOff > ERROR_MARGIN)\n    {\n      XMotor.setVelocity(-X_VELOCITY, percent);\n    }\n    else if (xDistanceOff <= ERROR_MARGIN)\n    {\n      XMotor.stop(brake);\n      xReached = true;\n    }\n\n    if (yLocation < y && yDistanceOff > ERROR_MARGIN)\n    {\n      YMotor.setVelocity(Y_VELOCITY, percent);\n    }\n    else if (yLocation > y && yDistanceOff > ERROR_MARGIN)\n    {\n      YMotor.setVelocity(-Y_VELOCITY, percent);\n    }\n    else if (yDistanceOff <= ERROR_MARGIN)\n    {\n      YMotor.stop(brake);\n      yReached = true;\n    }\n  }\n}\n\nvoid markerDown()\n{\n  MMotor.setMaxTorque(5, percent);\n  MMotor.setVelocity(100, percent);\n  MMotor.spin(forward);\n}\n\nvoid markerUp()\n{\n  MMotor.setMaxTorque(100, percent);\n  MMotor.setVelocity(100, percent);\n  MMotor.spin(reverse);\n  wait(200, msec);\n  MMotor.stop(brake);\n}\n\nvoid manualControlOverride()\n{\n  bool markerDown = true;\n  bool markerInProgress = false;\n  bool xSpinningForward = true;\n  bool ySpinningForward = true;\n\n  while (!Controller.ButtonFDown.pressing())\n  {\n    //moves along the x-axis\n    double xPos = XMotor.position(degrees);\n    int xAxisInput = Controller.AxisB.position();\n\n\n    //check boundaries: stop if at limit and trying to go further\n    if ((xPos <= 0 && xAxisInput < 0) || (xPos >= MAX_DEGREES_X && xAxisInput > 0))\n    {\n      //at boundary and trying to go further will stop motor completely\n      XMotor.stop(brake);\n    }\n    else if (xAxisInput > 0)\n    {\n      //moving away from origin (forward direction)\n      if (!xSpinningForward)\n      {\n        XMotor.stop();\n        xSpinningForward = true;\n      }\n      XMotor.setVelocity(xAxisInput/3, percent);\n      XMotor.spin(forward);\n    }\n    else if (xAxisInput < 0)\n    {\n      //moving towards origin (reverse direction)\n      if (xSpinningForward)\n      {\n        XMotor.stop();\n        xSpinningForward = false;\n      }\n      XMotor.setVelocity(-xAxisInput/3, percent);\n      XMotor.spin(reverse);\n    }\n    else\n    {\n      //no input will make it stop\n      XMotor.stop(brake);\n    }\n\n    //moves along the y-axis\n    double yPos = YMotor.position(degrees);\n    int yAxisInput = Controller.AxisA.position();\n\n    // Check boundaries: stop if at limit and trying to go further\n    if ((yPos <= 0 && yAxisInput < 0) || (yPos >= MAX_DEGREES_Y && yAxisInput > 0))\n    {\n      //at boundary and trying to go further will stop motor completely\n      YMotor.stop(brake);\n    }\n    else if (yAxisInput > 0)\n    {\n      //moving away from origin (forward direction)\n      if (!ySpinningForward)\n      {\n        YMotor.stop();\n        ySpinningForward = true;\n      }\n      YMotor.setVelocity(yAxisInput, percent);\n      YMotor.spin(forward);\n    }\n    else if (yAxisInput < 0)\n    {\n      //moving towards origin (reverse direction)\n      if (ySpinningForward)\n      {\n        YMotor.stop();\n        ySpinningForward = false;\n      }\n      YMotor.setVelocity(-yAxisInput, percent);\n      YMotor.spin(reverse);\n    }\n    else\n    {\n      //no input will make it stop\n      YMotor.stop(brake);\n    }\n    //moves marker down if pressed and marker not already down\n    if (Controller.ButtonRDown.pressing() && markerDown == false && markerInProgress == false)\n    {\n      markerInProgress = true;\n      markerDown = true;\n      // Set low torque for constant gentle pressure\n      MMotor.setMaxTorque(5, percent);\n      MMotor.setVelocity(100, percent);\n      MMotor.spin(forward);\n      markerInProgress = false;\n    }\n    //moves marker up if pressed and marker already down\n    if (Controller.ButtonRUp.pressing() && markerDown == true && markerInProgress == false)\n    {\n      markerInProgress = true;\n      markerDown = false;\n      //stop applying pressure and lift marker\n      MMotor.stop(brake);\n      //reset to full torque for lifting\n      MMotor.setMaxTorque(100, percent);\n      MMotor.setVelocity(100, percent);\n      MMotor.spin(reverse);\n      wait(200, msec);\n      MMotor.stop(brake);\n      markerInProgress = false;\n    }\n\n    // Keep marker pressing down with low torque when in down position\n    if (markerDown && !markerInProgress)\n    {\n      MMotor.setMaxTorque(5, percent);\n      MMotor.setVelocity(100, percent);\n      MMotor.spin(forward);\n    }\n    // Display coordinates in degrees (using positions already read above)\n    Brain.Screen.setCursor(1, 1);\n    Brain.Screen.clearLine();\n    Brain.Screen.print(\"X: %.1f deg  AxisB: %d\", xPos, xAxisInput);\n\n    Brain.Screen.setCursor(2, 1);\n    Brain.Screen.clearLine();\n    Brain.Screen.print(\"Y: %.1f deg  AxisA: %d\", yPos, yAxisInput);\n\n  }\n  XMotor.stop(brake);\n  YMotor.stop(brake);\n  MMotor.stop(brake);\n  if (markerDown)\n    markerUp();\n  calibrateAllAxes();\n}\n\nvoid markerSwitch()\n{\n  //percent speed of the marker motors\n  const int MARKER_RETRACT_SPEED = 20;\n  const int MARKER_INSERTION_SPEED = 20;\n\n  //time in seconds the marker motors will spin for\n  const int MARKER_RETRACT_TIME = 2;\n  const int MARKER_INSERTION_TIME = 2;\n\n    MMotor.setVelocity(MARKER_RETRACT_SPEED, percent);\n    MMotor.spin(reverse);\n\n    Brain.Screen.clearLine(1);\n    Brain.Screen.setCursor(1, 1);\n    Brain.Screen.print(\"Removing Marker...\");\n\n    wait(MARKER_RETRACT_TIME, seconds);\n    MMotor.stop(brake);\n\n    Brain.Screen.clearLine(1);\n    Brain.Screen.print(\"Marker ready to be inserted\");\n    Brain.Screen.setCursor(2, 1);\n    Brain.Screen.print(\"Press TouchLED when inserted\");\n\n    while(!TouchLED.pressing())\n    {\n    }\n\n    Brain.Screen.clearLine(1);\n    Brain.Screen.clearLine(2);\n\n    MMotor.setVelocity(MARKER_INSERTION_SPEED, percent);\n    MMotor.spin(forward);\n\n    Brain.Screen.setCursor(1, 1);\n    Brain.Screen.print(\"Inserting Marker...\");\n\n    wait(MARKER_INSERTION_TIME, seconds);\n    MMotor.stop(brake);\n\n    Brain.Screen.clearLine(1);\n    Brain.Screen.print(\"Marker switch complete!\");\n\n    wait(2, seconds);\n}\n\nvoid drawMenu(int selectedOption) {\n  const int NUM_OPTIONS = 5;\n  const char* menuOptions[] = {\n    \"Manual Control\",\n    \"Automator\",\n    \"Switch Marker\",\n    \"Recalibration\",\n    \"Shutdown\"\n  };\n\n  // colors for each menu option\n  color optionColors[] = {blue, green, purple, yellow, orange};\n\n  // Clear screen with the selected option's color\n  Brain.Screen.clearScreen(optionColors[selectedOption]);\n\n  Brain.Screen.setPenColor(white);\n  Brain.Screen.setFont(mono15);\n\n  // Draw menu options\n  for (int i = 0; i < NUM_OPTIONS; i++) {\n    Brain.Screen.setCursor(i + 1, 1);\n\n    // Highlight selected option with arrow and bright color\n    if (i == selectedOption) {\n      Brain.Screen.setPenColor(yellow);\n      Brain.Screen.print(\"> %s <\", menuOptions[i]);\n    } else {\n      Brain.Screen.setPenColor(white);\n      Brain.Screen.print(\"  %s\", menuOptions[i]);\n    }\n  }\n\n  Brain.Screen.setPenColor(white);\n\n  // Navigation instructions\n  Brain.Screen.setPenColor(white);\n  Brain.Screen.setCursor(7, 1);\n  Brain.Screen.setFont(mono12);\n  Brain.Screen.print(\"Left/Right: Navigate\");\n  Brain.Screen.setCursor(8, 1);\n  Brain.Screen.print(\"Check: Select\");\n}\n\nint mainMenu ()\n{\n  int selectedOption = 0;\n  const int NUM_OPTIONS = 5;\n\n  bool buttonPressed = false;\n  bool needsRedraw = true;\n\n  while (true) {\n    // Only redraw when selection changes\n    if (needsRedraw) {\n      drawMenu(selectedOption);\n      needsRedraw = false;\n    }\n\n    // Check for buttonLeft (navigate up)\n    if (Brain.buttonLeft.pressing()) {\n      if (!buttonPressed) {\n        buttonPressed = true;\n        selectedOption--;\n        if (selectedOption < 0) {\n          selectedOption = NUM_OPTIONS - 1; // Wrap to bottom\n        }\n        needsRedraw = true;\n        wait(200, msec); // Debounce\n      }\n    }\n    // Check for buttonRight (navigate down)\n    else if (Brain.buttonRight.pressing()) {\n      if (!buttonPressed) {\n        buttonPressed = true;\n        selectedOption++;\n        if (selectedOption >= NUM_OPTIONS) {\n          selectedOption = 0; // Wrap to top\n        }\n        needsRedraw = true;\n        wait(200, msec); // Debounce\n      }\n    }\n    // Check for buttonCheck (select option)\n    else if (Brain.buttonCheck.pressing()) {\n      if (!buttonPressed) {\n        buttonPressed = true;\n        wait(200, msec); // Show selection briefly\n        return selectedOption;\n      }\n    }\n    else {\n      buttonPressed = false;\n    }\n\n    wait(50, msec);\n  }\n\n  return selectedOption;\n}\n\nvoid penPressure(bool applyPressure)\n{\n  if (applyPressure == true) {\n      MMotor.setMaxTorque(5, percent);\n      MMotor.setVelocity(20, percent);\n      MMotor.spin(forward);\n  }\n  else {\n    MMotor.stop(brake);\n    MMotor.setMaxTorque(100, percent);\n    MMotor.setVelocity(50, percent);\n  }\n}\n\n// presents a color on touch led based on a certain state of robot\nvoid keepUserInformed(char C)\n{\n  // while homing all axies\n  if (C == 'H')\n  {\n    TouchLED.setColor(yellow);\n  }\n\n  // startup done and completed\n  else if (C == 'S')\n  {\n    TouchLED.setColor(green);\n  }\n\n  // autodraw\n  else if (C == 'A')\n  {\n    TouchLED.setColor(orange);\n  }\n\n  // controller\n  else if (C == 'C')\n  {\n    TouchLED.setColor(blue);\n  }\n\n  // marker switcher\n  else if (C == 'M')\n  {\n    TouchLED.setColor(purple);\n  }\n\n  // limit triggered unexpectedly\n  else if (C == 'T')\n  {\n    // use return to main menu function\n  }\n\n  // paper is removed\n  else if (C == 'R')\n  {\n    TouchLED.setColor(red);\n    while (!TouchLED.pressing())\n    {\n      wait(0.5, seconds);\n      TouchLED.setFade(fast);\n      wait(0.5, seconds);\n      TouchLED.setBrightness(100);\n    }\n    TouchLED.off();\n  }\n\n  // shutdown procedure\n  else if (C == 'P')\n  {\n    TouchLED.setColor(red);\n  }\n\n}\n\nconst float SEGMENTS_P1[][2][2] = {\n\t{{1.0, 1}, {1.0, 10}},\n\t{{2.5, 10.0}, {6, 10.0}},\n\t{{7.5, 1}, {7.5, 10}},\n\t{{2.5, 1.0}, {6, 1.0}},\n\t{{1.25, 1}, {1.25, 10}},\n\t{{2.5, 9.75}, {6, 9.75}},\n\t{{7.25, 1}, {7.25, 10}},\n\t{{2.5, 1.25}, {6, 1.25}},\n\t{{1.5, 1}, {1.5, 10}},\n\t{{2.5, 9.5}, {6, 9.5}},\n\t{{7.0, 1}, {7.0, 10}},\n\t{{2.5, 1.5}, {6, 1.5}},\n\t{{1.75, 1}, {1.75, 10}},\n\t{{2.5, 9.25}, {6, 9.25}},\n\t{{6.75, 1}, {6.75, 10}},\n\t{{2.5, 1.75}, {6, 1.75}},\n\t{{2.0, 1}, {2.0, 10}},\n\t{{2.5, 9.0}, {6, 9.0}},\n\t{{6.5, 1}, {6.5, 10}},\n\t{{2.5, 2.0}, {6, 2.0}},\n\t{{4.25, 5.5}, {4.283333333333333, 5.5}},\n\t{{4.283333333333333, 5.5}, {4.303172261921682, 5.540213865849686}},\n\t{{4.303172261921682, 5.540213865849686}, {4.2772280247040575, 5.596221799352929}},\n\t{{4.2772280247040575, 5.596221799352929}, {4.201566502603603, 5.624225497011406}},\n\t{{4.201566502603603, 5.624225497011406}, {4.108045510976159, 5.5873309843283465}},\n\t{{4.108045510976159, 5.5873309843283465}, {4.050920760326564, 5.4808308494959554}},\n\t{{4.050920760326564, 5.4808308494959554}, {4.078244013005396, 5.342062273740712}},\n\t{{4.078244013005396, 5.342062273740712}, {4.202319409302307, 5.2376306565510555}},\n\t{{4.202319409302307, 5.2376306565510555}, {4.385263262206829, 5.232224254464362}},\n\t{{4.385263262206829, 5.232224254464362}, {4.549342525253539, 5.353353610048028}},\n\t{{4.549342525253539, 5.353353610048028}, {4.609929967264144, 5.569963298304733}},\n\t{{4.609929967264144, 5.569963298304733}, {4.5171330221884185, 5.797724618492461}},\n\t{{4.5171330221884185, 5.797724618492461}, {4.286260398777337, 5.931813572341452}},\n\t{{4.286260398777337, 5.931813572341452}, {4.000635570284747, 5.894455522170199}},\n\t{{4.000635570284747, 5.894455522170199}, {3.7819702321305133, 5.675920824202351}},\n\t{{3.7819702321305133, 5.675920824202351}, {3.7386294747369635, 5.348525149491241}},\n\t{{3.7386294747369635, 5.348525149491241}, {3.913729297591236, 5.043893514831649}},\n\t{{3.913729297591236, 5.043893514831649}, {4.257330200501149, 4.900044778203728}},\n\t{{4.257330200501149, 4.900044778203728}, {4.6381744673135525, 4.999568492162063}},\n\t{{4.6381744673135525, 4.999568492162063}, {4.89364842058615, 5.326330327571568}},\n\t{{4.89364842058615, 5.326330327571568}, {4.8990286981967515, 5.762224615391139}},\n\t{{4.8990286981967515, 5.762224615391139}, {4.6265969181759905, 6.129247597530673}},\n\t{{4.6265969181759905, 6.129247597530673}, {4.167200493958716, 6.2621824057121085}},\n\t{{4.167200493958716, 6.2621824057121085}, {3.701345317658099, 6.082218206125768}},\n\t{{3.701345317658099, 6.082218206125768}, {3.428336635774579, 5.638973955596751}},\n\t{{3.428336635774579, 5.638973955596751}, {3.4812572779122077, 5.099817868529637}},\n\t{{3.4812572779122077, 5.099817868529637}, {3.863958379937169, 4.68699823642303}},\n\t{{3.863958379937169, 4.68699823642303}, {4.439268142332746, 4.586058710086352}},\n\t{{4.439268142332746, 4.586058710086352}, {4.9773344119325325, 4.863266855218607}},\n\t{{4.9773344119325325, 4.863266855218607}, {5.247440782930944, 5.428502555667316}},\n\t{{5.247440782930944, 5.428502555667316}, {5.116626253543606, 6.062793669515527}},\n\t{{5.116626253543606, 6.062793669515527}, {4.61307152022725, 6.502974002144448}},\n\t{{4.61307152022725, 6.502974002144448}, {3.9247211449515484, 6.550806198334578}},\n\t{{3.9247211449515484, 6.550806198334578}, {3.3296386695226188, 6.1613467062036}},\n\t{{3.3296386695226188, 6.1613467062036}, {3.0836815952552863, 5.4714957921552365}},\n\t{{3.0836815952552863, 5.4714957921552365}, {3.310870211777102, 4.752982436034858}},\n\t{{3.310870211777102, 4.752982436034858}, {3.9432824724966817, 4.305414101274687}},\n\t{{3.9432824724966817, 4.305414101274687}, {4.738814320277469, 4.331451753355421}},\n\t{{4.738814320277469, 4.331451753355421}, {5.373557242539816, 4.846074069380694}},\n\t{{5.373557242539816, 4.846074069380694}, {5.573676455905927, 5.66018245177953}},\n\t{{5.573676455905927, 5.66018245177953}, {5.233097727129489, 6.449366439627298}},\n\t{{5.233097727129489, 6.449366439627298}, {4.466594540819253, 6.8831438120771455}},\n\t{{4.466594540819253, 6.8831438120771455}, {3.57267723702102, 6.763201614626487}},\n\t{{3.57267723702102, 6.763201614626487}, {2.9175213396274753, 6.11287170824158}},\n\t{{2.9175213396274753, 6.11287170824158}, {2.784991582498748, 5.177897009249405}},\n\t{{2.784991582498748, 5.177897009249405}, {3.2541796592270518, 4.334044186079952}},\n\t{{3.2541796592270518, 4.334044186079952}, {4.1570866813976615, 3.9360909362527674}},\n\t{{4.1570866813976615, 3.9360909362527674}, {5.1377510839168, 4.1688734045912295}},\n\t{{5.1377510839168, 4.1688734045912295}, {5.7924814047212205, 4.962851143660317}},\n\t{{5.7924814047212205, 4.962851143660317}, {5.835990673132396, 6.012261029666349}},\n\t{{5.835990673132396, 6.012261029666349}, {5.225079941796779, 6.892558475291286}},\n\t{{5.225079941796779, 6.892558475291286}, {4.186484238241969, 7.232169215883005}},\n\t{{4.186484238241969, 7.232169215883005}, {3.1334148986254293, 6.869068596710717}},\n\t{{3.1334148986254293, 6.869068596710717}, {2.5012115840042366, 5.926308662918112}},\n\t{{2.5012115840042366, 5.926308662918112}, {2.567449852912702, 4.771895533836233}},\n\t{{2.567449852912702, 4.771895533836233}, {3.3308093544735318, 3.8753360342455183}},\n\t{{3.3308093544735318, 3.8753360342455183}, {4.5012871414885245, 3.6166904735220697}},\n\t{{4.5012871414885245, 3.6166904735220697}, {5.609896425433646, 4.1257876838455525}},\n\t{{5.609896425433646, 4.1257876838455525}, {6.19655992078532, 5.219496430379168}},\n\t{{6.19655992078532, 5.219496430379168}, {6.000929054000031, 6.466564766510013}}\n};\n\nconst float AUTOMATED_TOLERANCE = 0.05;\n\nvoid automatedDrawing(const float segments[][2][2], const int segs) {\n\tfloat xloc = 0; float yloc = 0;\n\t\n\tbool markerDownYet = false;\n\t\n\tfor (int cseg=0; cseg<segs; cseg++) {\n\t\t// TODO: convert to inches\n\t\txloc = (static_cast<float>(XMotor.position(degrees)))/GEAR_RATIO_X;\n\t\tyloc = (static_cast<float>(YMotor.position(degrees)))/GEAR_RATIO_Y;\n\t\t\n\t\t// If farther than 0.05 on either axis from the start of next line, pick up marker and move there\n\t\tif (abs(xloc)-abs(segments[cseg][0][0]) > AUTOMATED_TOLERANCE || abs(yloc)-abs(segments[cseg][0][1]) > AUTOMATED_TOLERANCE) {\n\t\t\tmarkerUp();\n\t\t\tmoveTo(segments[cseg][0][0], segments[cseg][0][1]);\n\t\t\tmarkerDown();\n\t\t\tmarkerDownYet = true;\n\t\t}\n\t\t// Move to end of line segment with marker down\n\t\tif (!markerDownYet) {\n\t\t\tmarkerDown();\n\t\t\tmarkerDownYet = true;\n\t\t}\n\t\tmoveTo(segments[cseg][1][0], segments[cseg][1][1]);\n\t}\n}\n\nint main() {\n  // Initializing Robot Configuration. DO NOT REMOVE!\n  vexcodeInit();\n  XMotor.setPosition(0, degrees);\n  YMotor.setPosition(0, degrees);\n  MMotor.setPosition(0, degrees);\n\n  // Begin project code\n\n  // Initial calibration\n  calibrateAllAxes();\n  // Main menu loop\n  while (true) {\n    int selection = mainMenu();\n\n    switch (selection) {\n      case 0: // Manual Control\n        //Brain.Screen.clearScreen();\n        Brain.Screen.setCursor(1, 1);\n        Brain.Screen.print(\"Starting Manual Mode\");\n        wait(500, msec);\n        manualControlOverride();\n        break;\n\n      case 1: // Automator\n        //Brain.Screen.clearScreen();\n        automatedDrawing(SEGMENTS_P1, 80);\n        wait(2, seconds);\n        break;\n\n      case 2: // Switch Marker\n        //Brain.Screen.clearScreen();\n        Brain.Screen.setCursor(1, 1);\n        Brain.Screen.print(\"Starting Marker Switch\");\n        keepUserInformed('M');\n        wait(500, msec);\n        markerSwitch();\n        break;\n\n      case 3: // Recalibration\n        //Brain.Screen.clearScreen();\n        Brain.Screen.setCursor(1, 1);\n        Brain.Screen.print(\"Recalibrating...\");\n        calibrateAllAxes();\n        Brain.Screen.setCursor(2, 1);\n        Brain.Screen.print(\"Done!\");\n        wait(1, seconds);\n        break;\n\n      case 4: // Shutdown\n        //Brain.Screen.clearScreen();\n        Brain.Screen.setCursor(1, 1);\n        Brain.Screen.print(\"Shutting down...\");\n        keepUserInformed('P');\n        wait(1, seconds);\n        Brain.programStop();\n        return 0;\n    }\n  }\n\n  Brain.programStop();\n}\n","textLanguage":"cpp","robotConfig":[{"port":[3],"name":"XMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[6],"name":"YMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[2],"name":"MMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[4],"name":"YCalSwitch","customName":true,"deviceType":"Bumper","deviceClass":"bumper","setting":{},"triportSourcePort":22},{"port":[],"name":"Controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22},{"port":[5],"name":"TouchLED","customName":true,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[1],"name":"XCalDistance","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.62.0","fileFormat":"2.0.0","targetBrainGen":"Second","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null}}