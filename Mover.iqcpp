{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\ninertial BrainInertial = inertial();\nmotor XMotor = motor(PORT3, true);\nmotor YMotor = motor(PORT6, true);\nmotor MMotor = motor(PORT2, false);\nbumper YCalSwitch = bumper(PORT4);\ncontroller Controller = controller();\ntouchled TouchLED = touchled(PORT5);\ndistance XCalDistance = distance(PORT1);\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  wait(100,msec);\n  double xAxis = BrainInertial.acceleration(xaxis) * 1000;\n  double yAxis = BrainInertial.acceleration(yaxis) * 1000;\n  double zAxis = BrainInertial.acceleration(zaxis) * 1000;\n  // Combine these values into a single integer\n  int seed = int(\n    xAxis + yAxis + zAxis\n  );\n  // Set the seed\n  srand(seed); \n}\n\n\n\nvoid vexcodeInit() {\n\n  // Initializing random seed.\n  initializeRandomSeed(); \n}\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n//----------------------------------------------------------------------------\n//                                                                            \n//    Module:       main.cpp                                                  \n//    Author:       {author}                                                  \n//    Created:      {date}                                                    \n//    Description:  IQ project                                                \n//                                                                            \n//----------------------------------------------------------------------------\n\n// Include the IQ Library\n#include \"iq_cpp.h\"\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\nconst int MAX_DEGREES_X = -1800;\nconst int MAX_DEGREES_Y = -3500;\n\nclass Mover {\n  private:\n    bool XTargetSet, YTargetSet, MTargetSet;\n    float XTarget, YTarget, MTarget;\n    float DXSpeed, DYSpeed, DMSpeed,\n        UXSpeed, UYSpeed, UMSpeed;\n\n    bool paused, stopped;\n\n    // In mm/degree\n    const float X_MM_PER_DEG = 0.25;\n    const float Y_MM_PER_DEG = 0.05;\n    const float M_MM_PER_DEG = 1.8;\n\n    // In degrees/s\n    const float MAX_MOTOR_SPEED_DEG_PER_S = 90.0;\n    const float MIN_MOTOR_SPEED_PERCENT = 0.03;\n    // In mm/s\n    const float MAX_X_SPEED = X_MM_PER_DEG*MAX_MOTOR_SPEED_DEG_PER_S;\n    const float MAX_Y_SPEED = Y_MM_PER_DEG*MAX_MOTOR_SPEED_DEG_PER_S;\n    const float MAX_M_SPEED = M_MM_PER_DEG*MAX_MOTOR_SPEED_DEG_PER_S;\n    const float PERCENT = 100.0;\n\n    // In mm\n    const float MAX_TARGET_TOLERANCE = 0.8;\n    const float MAX_SPEED_AT_TARGET = 0.2;\n\n    // K-values for PID\n    const float K_P = 0.1;\n    const float K_I = 0;\n    const float K_D = 0;\n\n    const float X_MIN = 0.0;\n    const float Y_MIN = 0.0;\n    const float M_MIN = 0.0;\n\n    const float X_MAX = 11.0*25.4;\n    const float Y_MAX = 8.5*25.4;\n    const float M_MAX = 20.0;\n  \n    float getXAPos () {\n      return X_MM_PER_DEG*XMotor.position(degrees);\n    }\n    float getYAPos() {\n      return Y_MM_PER_DEG*YMotor.position(degrees);\n    }\n    int getMAPos() {\n      return M_MM_PER_DEG*MMotor.position(degrees);\n    }\n\n    void setXASpeed(float aXSpeed) {\n      if (abs(aXSpeed/MAX_X_SPEED*PERCENT) > MIN_MOTOR_SPEED_PERCENT) {\n        XMotor.setVelocity(aXSpeed/MAX_X_SPEED*PERCENT, percent);\n        XMotor.spin(forward);\n      } else {\n        XMotor.stop();\n      }\n    }\n    void setYASpeed(float aYSpeed) {\n      if (abs(aYSpeed/MAX_Y_SPEED*PERCENT) > MIN_MOTOR_SPEED_PERCENT) {\n        YMotor.setVelocity(aYSpeed/MAX_Y_SPEED*PERCENT, percent);\n        YMotor.spin(forward);\n      } else {\n        YMotor.stop();\n      }\n    }\n    void setMASpeed(float aMSpeed) {\n      if (abs(aMSpeed/MAX_M_SPEED*PERCENT) > MIN_MOTOR_SPEED_PERCENT) {\n        MMotor.setVelocity(aMSpeed/MAX_M_SPEED*PERCENT, percent);\n        MMotor.spin(forward);\n      } else {\n        MMotor.stop();\n      }\n    }\n\n    void pauseXMotor() {\n      if (UXSpeed != 0.0) {\n        setXASpeed(0.0);\n        UXSpeed = 0.0;\n      }\n    }\n    bool updateXSpeed() {\n      // Check lower bound (at origin, position = 0)\n      if (DXSpeed < 0 && getXAPos()<=X_MIN) {\n        // Below lower bound\n        pauseXMotor();\n        return false;\n      }\n      // Check upper bound\n      if (DXSpeed > 0 && getXAPos()>=X_MAX) {\n        // Above upper bound\n        pauseXMotor();\n        return false;\n      }\n      if (DXSpeed != UXSpeed) {\n        setXASpeed(DXSpeed);\n        UXSpeed = DXSpeed;\n        return true;\n      }\n      return false;\n    }\n\n    void pauseYMotor() {\n      if (UYSpeed != 0.0) {\n        setYASpeed(0.0);\n        UYSpeed = 0.0;\n      }\n    }\n    bool updateYSpeed() {\n      // Check lower bound (at origin, position = 0)\n      if (DYSpeed < 0 && getYAPos()<=Y_MIN) {\n        // Below lower bound\n        pauseYMotor();\n        return false;\n      }\n      // Check upper bound\n      if (DYSpeed > 0 && getYAPos()>=Y_MAX) {\n        // Above upper bound\n        pauseYMotor();\n        return false;\n      }\n      if (DYSpeed != UYSpeed) {\n        setYASpeed(DYSpeed);\n        UYSpeed = DYSpeed;\n        return true;\n      }\n      return false;\n    }\n\n    void pauseMMotor() {\n      if (UMSpeed != 0.0) {\n        setMASpeed(0.0);\n        UMSpeed = 0.0;\n      }\n    }\n    bool updateMSpeed() {\n      if (DMSpeed < 0 && getMAPos()<=M_MIN) {\n        // Below lower bound\n        pauseMMotor();\n      }\n      if (DMSpeed > 0 && getMAPos()>=M_MAX) {\n        // Above upper bound\n        pauseMMotor();\n      }\n      if (DMSpeed != UMSpeed) {\n        setMASpeed(DMSpeed);\n        UMSpeed = DMSpeed;\n        return true;\n      }\n      return false;\n    }\n\n    void ifXTargetSetPIDControl() {\n      if (XTargetSet) {\n        float toCover = XTarget - getXAPos();\n        if (abs(toCover) < MAX_TARGET_TOLERANCE && abs(UXSpeed) < MAX_SPEED_AT_TARGET) {\n          XTargetSet = false;\n          pauseXMotor();\n        } else {\n          DXSpeed = K_P*toCover;\n        }\n      }\n    }\n  \n  public:\n    Mover() {\n      XTargetSet = false;\n      YTargetSet = false;\n      MTargetSet = false;\n      \n      // In mm\n      XTarget = 0.0;\n      YTarget = 0.0;\n      MTarget = 0.0;\n\n      // Desired Speed In mm/s\n      DXSpeed = 0.0;\n      DYSpeed = 0.0;\n      DMSpeed = 0.0;\n\n      UXSpeed = 0.0;\n      UYSpeed = 0.0;\n      UMSpeed = 0.0;\n\n      paused = false;\n      stopped = false;\n    }\n\n    float getXSpeed() {\n      return UXSpeed;\n    }\n    float getYSpeed() {\n      return UYSpeed;\n    }\n    float getMSpeed() {\n      return UMSpeed;\n    }\n\n    bool setXSpeed(float nXSpeed) {\n      if (nXSpeed != DXSpeed) {\n        if (nXSpeed < -MAX_X_SPEED) {\n          DXSpeed = -MAX_X_SPEED;\n        } else if (nXSpeed > MAX_X_SPEED) {\n          DXSpeed = MAX_X_SPEED;\n        } else {\n          DXSpeed = nXSpeed;\n        }\n        return true;\n      }\n      return false;\n    }\n    bool setYSpeed(float nYSpeed) {\n      if (nYSpeed != DYSpeed) {\n        if (nYSpeed < -MAX_Y_SPEED) {\n          DYSpeed = -MAX_Y_SPEED;\n        } else if (nYSpeed > MAX_Y_SPEED) {\n          DYSpeed = MAX_Y_SPEED;\n        } else {\n          DYSpeed = nYSpeed;\n        }\n        return true;\n      }\n      return false;\n    }\n    bool setMSpeed(float nMSpeed) {\n      if (nMSpeed != DMSpeed) {\n        if (nMSpeed < -MAX_M_SPEED) {\n          DMSpeed = -MAX_M_SPEED;\n        } else if (nMSpeed > MAX_M_SPEED) {\n          DMSpeed = MAX_M_SPEED;\n        } else {\n        DMSpeed = nMSpeed;\n        }\n        return true;\n      }\n      return false;\n    }\n\n    bool isXTargetSet() {\n      return XTargetSet;\n    }\n    bool setXTarget(float nXTarget) {\n      if (nXTarget < X_MIN || nXTarget > X_MAX) {\n        return false;\n      }\n      XTarget = nXTarget;\n      XTargetSet = true;\n      return true;\n    }\n    bool reachedXTarget() {\n      return (abs(XTarget-getXAPos()) < MAX_TARGET_TOLERANCE);\n    }\n\n    // Return whether now paused\n    bool changePause() {\n      paused = !paused;\n      return paused;\n    }\n    // Return whether change occured\n    bool pause() {\n      if (!paused) {\n        paused = true;\n        return true;\n      }\n      return false;\n    }\n    bool unPause() {\n      if (paused) {\n        paused = false;\n        return true;\n      }\n      return false;\n    }\n\n    bool tick() {\n      if (paused) {\n        pauseXMotor();\n        pauseYMotor();\n        pauseMMotor();\n      }\n      else {\n        // Target processing\n        ifXTargetSetPIDControl();\n        \n        // Speed updating\n        if (updateXSpeed() || updateYSpeed() || updateMSpeed()) {\n          // Moved successfully\n        }\n        else {\n          // Attempting to move to unreachable location - Stuck\n          return false;\n        }\n      }\n      return true;\n    }\n};\n\nvoid calibrateAllAxes()\n{\n  const int SAMPLES = 3;\n  const double APPROACH_SPEED = 10.0; //towards sensor\n  const double RETRACT_SPEED = 20; //away from sensor\n\n\n  double samplesY[SAMPLES];\n\n  for (int i = 0; i < SAMPLES; i++) //move away until not pressed\n  {\n    YMotor.setVelocity(RETRACT_SPEED, percent);\n    YMotor.spin(forward);\n    while (YCalSwitch.pressing()) \n    {\n    }\n    YMotor.stop(brake);\n    wait(200,msec);//pause to settle\n\n    //move slowly toards sernsor unitl pressed\n\n    YMotor.setVelocity(APPROACH_SPEED*3, percent);\n    YMotor.spin(reverse);\n    while (!YCalSwitch.pressing()) \n    {\n    }\n    YMotor.stop(brake);\n    //records position\n    samplesY[i] = YMotor.position(degrees);\n\n    //pause to settle \n    wait(2000,msec);\n\n    //calibrate x axis\n  }\n  //average contact position calculation\n  double avgDeg = (samplesY[0] + samplesY[1] + samplesY[2]) / SAMPLES;\n  //shift encoder so the position becomes 0\n  double currentDeg = YMotor.position(degrees);\n  YMotor.setPosition(currentDeg - avgDeg, degrees);\n\n    //x axis calibration\n    double samplesX[SAMPLES];\n\n    for (int i = 0; i < SAMPLES; i++) //move away until not pressed\n    {\n      XMotor.setVelocity(RETRACT_SPEED, percent);\n      XMotor.spin(forward);\n      while (XCalDistance.objectDistance(mm) < 60) \n      {\n      }\n      XMotor.stop(brake);\n      wait(200, msec); //pause to settle\n\n      //mmove slowly towards sensor until \n      XMotor.setVelocity(APPROACH_SPEED*2, percent);\n      XMotor.spin(reverse);\n      while (XCalDistance.objectDistance(mm) > 40) \n      {\n      }\n      XMotor.stop(brake);\n      //records position\n      samplesX[i] = XMotor.position(degrees);\n    }\n\n    //average contact position calculation\n    double avgDegX = (samplesX[0] + samplesX[1] + samplesX[2]) / SAMPLES;\n    double currentDegX = XMotor.position(degrees);\n    XMotor.setPosition(currentDegX - avgDegX, degrees);\n}\n\nvoid manualControlOverride()\n{\n  bool markerDown = false;\n  bool markerInProgress = false;\n  bool xSpinningForward = true;\n  bool ySpinningForward = true;\n  \n  while (!Controller.ButtonFDown.pressing())\n  {\n    //moves along the x-axis\n    double xPos = XMotor.position(degrees);\n    int xAxisInput = Controller.AxisB.position();\n    \n    //check boundaries: stop if at limit and trying to go further\n    if ((xPos >= 0 && xAxisInput < 0) || (xPos <= MAX_DEGREES_X && xAxisInput > 0))\n    {\n      //at boundary and trying to go further will stop motor completely\n      XMotor.stop(brake);\n    }\n    else if (xAxisInput > 0)\n    {\n      //moving away from origin (forward direction)\n      if (!xSpinningForward)\n      {\n        XMotor.stop();\n        xSpinningForward = true;\n      }\n      XMotor.setVelocity(xAxisInput/3, percent);\n      XMotor.spin(forward);\n    }\n    else if (xAxisInput < 0)\n    {\n      //moving towards origin (reverse direction)\n      if (xSpinningForward)\n      {\n        XMotor.stop();\n        xSpinningForward = false;\n      }\n      XMotor.setVelocity(-xAxisInput/3, percent);\n      XMotor.spin(reverse);\n    }\n    else\n    {\n      //no input will make it stop\n      XMotor.stop(brake);\n    }\n\n    //moves along the y-axis\n    double yPos = YMotor.position(degrees);\n    int yAxisInput = Controller.AxisA.position();\n    \n    //check boundaries and stop if at limit and trying to go further\n    if ((yPos >= 0 && yAxisInput < 0) || (yPos <= MAX_DEGREES_Y && yAxisInput > 0))\n    {\n      //at boundary and trying to go further will stop motor completely\n      YMotor.stop(brake);\n    }\n    else if (yAxisInput > 0)\n    {\n      //moving away from origin (forward direction)\n      if (!ySpinningForward)\n      {\n        YMotor.stop();\n        ySpinningForward = true;\n      }\n      YMotor.setVelocity(yAxisInput, percent);\n      YMotor.spin(forward);\n    }\n    else if (yAxisInput < 0)\n    {\n      //moving towards origin (reverse direction)\n      if (ySpinningForward)\n      {\n        YMotor.stop();\n        ySpinningForward = false;\n      }\n      YMotor.setVelocity(-yAxisInput, percent);\n      YMotor.spin(reverse);\n    }\n    else\n    {\n      //no input will make it stop\n      YMotor.stop(brake);\n    }\n    //moves marker down if pressed and marker not already down\n    if (Controller.ButtonRDown.pressing() && markerDown == false && markerInProgress == false)\n    {\n      markerInProgress = true;\n      markerDown = true;\n      MMotor.setVelocity(100, percent);\n      MMotor.spin(forward);\n      wait(200, msec);\n      MMotor.stop(brake);\n      markerInProgress = false;\n    }\n    //moves marker up if pressed and marker not already down\n    if (Controller.ButtonRUp.pressing() && markerDown == true && markerInProgress == false)\n    {\n      markerInProgress = true;\n      markerDown = false;\n      MMotor.setVelocity(100, percent);\n      MMotor.spin(reverse);\n      wait(200, msec);\n      MMotor.stop(brake);\n      markerInProgress = false;\n    }\n    // Display coordinates in degrees (using positions already read above)\n    Brain.Screen.setCursor(1, 1);\n    Brain.Screen.clearLine();\n    Brain.Screen.print(\"X: %.1f  Y: %.1f  AxisB: %d  AxisA: %d\", xPos, yPos, xAxisInput, yAxisInput);\n\n  }\n  XMotor.stop(brake);\n  YMotor.stop(brake);\n}\n\nint main() {\n  // Initializing Robot Configuration. DO NOT REMOVE!\n  vexcodeInit();\n  XMotor.setPosition(0, degrees);\n  YMotor.setPosition(0, degrees);\n  MMotor.setPosition(0, degrees);\n\n  // Begin project code\n\n  calibrateAllAxes();\n  manualControlOverride();\n\n  Mover m;\n\n  m.setXSpeed(3);\n\n  for (int i=0; i<500000; i++) {\n    m.tick();\n    if (i==250000) {\n      m.setXSpeed(-3);\n    }\n  }\n\n  Brain.programStop();\n}\n","textLanguage":"cpp","robotConfig":[{"port":[3],"name":"XMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[6],"name":"YMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[2],"name":"MMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[4],"name":"YCalSwitch","customName":true,"deviceType":"Bumper","deviceClass":"bumper","setting":{},"triportSourcePort":22},{"port":[],"name":"Controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22},{"port":[5],"name":"TouchLED","customName":true,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[1],"name":"XCalDistance","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.62.0","fileFormat":"2.0.0","targetBrainGen":"Second","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null}}